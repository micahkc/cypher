"""
Automatically generated by Rumoca
"""
import sympy
from sympy import Matrix, ImmutableDenseMatrix, Piecewise, Tuple
import numpy as np
import scipy.integrate

cos = sympy.cos
sin = sympy.sin
tan = sympy.tan


def flatten_piecewise_with_nested_matrices(matrix):
    assert isinstance(matrix, (Matrix, ImmutableDenseMatrix, Tuple)), "Input must be a Matrix object or Tuple"
    piecewise = sympy.piecewise_fold(sympy.Piecewise((matrix, True)))

    if isinstance(piecewise, (Matrix, ImmutableDenseMatrix, Tuple)):
        return piecewise

    def flatten_matrix(matrix):
        """Recursively flatten nested matrices."""
        if isinstance(matrix, (Matrix, ImmutableDenseMatrix, Tuple)):
            flattened = []
            for elem in matrix:
                if isinstance(elem, (Matrix, ImmutableDenseMatrix, Tuple)):
                    flattened.extend(flatten_matrix(elem))
                else:
                    flattened.append(elem)
            return Matrix(flattened)
        return matrix

    flattened_conditions = []
    for expr, cond in piecewise.args:
        flattened_expr = flatten_matrix(expr) if isinstance(expr, (Matrix, ImmutableDenseMatrix, Tuple)) else expr
        flattened_conditions.append((flattened_expr, cond))
    return sympy.piecewise_exclusive(Piecewise(*flattened_conditions))


class Model:
    """
    Flattened Modelica Model
    """

    def __init__(self):
        # ============================================
        # Initialize
        self.solved = False

        # ============================================
        # Declare time
        time = sympy.symbols('time')
        self.time = time

        # ============================================
        # Declare u
        theta_ref = sympy.symbols('theta_ref')
        dtheta_ref = sympy.symbols('dtheta_ref')
        ddtheta_ref = sympy.symbols('ddtheta_ref')
        d = sympy.symbols('d')
        self.u = sympy.Matrix([
            theta_ref,
            dtheta_ref,
            ddtheta_ref,
            d])
        self.u0 = { 
            'theta_ref': 0.0,
            'dtheta_ref': 0.0,
            'ddtheta_ref': 0.0,
            'd': 0.0}
        self.u_index = { 
            'theta_ref': 0,
            'dtheta_ref': 1,
            'ddtheta_ref': 2,
            'd': 3}
        self.u_index_rev = [ 
            'theta_ref',
            'dtheta_ref',
            'ddtheta_ref',
            'd']
        # ============================================
        # Declare p
        m = sympy.symbols('m')
        l = sympy.symbols('l')
        g = sympy.symbols('g')
        c = sympy.symbols('c')
        Kp = sympy.symbols('Kp')
        Ki = sympy.symbols('Ki')
        Kd = sympy.symbols('Kd')
        N = sympy.symbols('N')
        self.p = sympy.Matrix([
            m,
            l,
            g,
            c,
            Kp,
            Ki,
            Kd,
            N])
        self.p0 = { 
            'm': 0.0,
            'l': 0.0,
            'g': 0.0,
            'c': 0.0,
            'Kp': 0.0,
            'Ki': 0.0,
            'Kd': 0.0,
            'N': 0.0}
        self.p_index = { 
            'm': 0,
            'l': 1,
            'g': 2,
            'c': 3,
            'Kp': 4,
            'Ki': 5,
            'Kd': 6,
            'N': 7}
        self.p_index_rev = [ 
            'm',
            'l',
            'g',
            'c',
            'Kp',
            'Ki',
            'Kd',
            'N']
        # ============================================
        # Declare c
        self.c = sympy.Matrix([])
        self.c0 = { }
        self.c_index = { }
        self.c_index_rev = [ ]
        # ============================================
        # Declare cp
        self.cp = sympy.Matrix([])
        self.cp0 = { }
        self.cp_index = { }
        self.cp_index_rev = [ ]
        # ============================================
        # Declare x
        theta = sympy.symbols('theta')
        omega = sympy.symbols('omega')
        xi = sympy.symbols('xi')
        omega_f = sympy.symbols('omega_f')
        self.x = sympy.Matrix([
            theta,
            omega,
            xi,
            omega_f])
        self.x0 = { 
            'theta': 0.0,
            'omega': 0.0,
            'xi': 0.0,
            'omega_f': 0.0}
        self.x_index = { 
            'theta': 0,
            'omega': 1,
            'xi': 2,
            'omega_f': 3}
        self.x_index_rev = [ 
            'theta',
            'omega',
            'xi',
            'omega_f']
        # ============================================
        # Declare m
        self.m = sympy.Matrix([])
        self.m0 = { }
        self.m_index = { }
        self.m_index_rev = [ ]
        # ============================================
        # Declare y
        e = sympy.symbols('e')
        u = sympy.symbols('u')
        u_ff = sympy.symbols('u_ff')
        self.y = sympy.Matrix([
            e,
            u,
            u_ff])
        self.y0 = { 
            'e': 0.0,
            'u': 0.0,
            'u_ff': 0.0}
        self.y_index = { 
            'e': 0,
            'u': 1,
            'u_ff': 2}
        self.y_index_rev = [ 
            'e',
            'u',
            'u_ff']
        # ============================================
        # Declare z
        self.z = sympy.Matrix([])
        self.z0 = { }
        self.z_index = { }
        self.z_index_rev = [ ]
        

        # ============================================
        # Declare pre_x
        pre_theta = sympy.symbols('pre_theta')
        pre_omega = sympy.symbols('pre_omega')
        pre_xi = sympy.symbols('pre_xi')
        pre_omega_f = sympy.symbols('pre_omega_f')
        self.pre_x = sympy.Matrix([
            pre_theta,
            pre_omega,
            pre_xi,
            pre_omega_f])

        # ============================================
        # Declare pre_m
        self.pre_m = sympy.Matrix([])

        # ============================================
        # Declare pre_z
        self.pre_z = sympy.Matrix([])

        # ============================================
        # Declare x_dot
        der_theta = sympy.symbols('der_theta')
        der_omega = sympy.symbols('der_omega')
        der_xi = sympy.symbols('der_xi')
        der_omega_f = sympy.symbols('der_omega_f')
        self.x_dot = sympy.Matrix([
            der_theta,
            der_omega,
            der_xi,
            der_omega_f])

        # ============================================
        # Define Continous Update Function: fx
        self.fx = sympy.Matrix([
            der_theta - (omega),
            der_omega - (((-(((g / l) * sin(theta))) - ((c / (m * (l UNHANDLED OP: {
    "Exp": {
        "location": {
            "end": 0,
            "end_column": 0,
            "end_line": 0,
            "file_name": "",
            "start": 0,
            "start_column": 0,
            "start_line": 0,
        },
        "text": "",
        "token_number": 0,
        "token_type": 0,
    },
} 2.0))) * omega)) + ((u + d) / (m * (l UNHANDLED OP: {
    "Exp": {
        "location": {
            "end": 0,
            "end_column": 0,
            "end_line": 0,
            "file_name": "",
            "start": 0,
            "start_column": 0,
            "start_line": 0,
        },
        "text": "",
        "token_number": 0,
        "token_type": 0,
    },
} 2.0))))),
            e - ((theta_ref - theta)),
            der_xi - (e),
            der_omega_f - ((N * (omega - omega_f))),
            u_ff - (((((m * (l UNHANDLED OP: {
    "Exp": {
        "location": {
            "end": 0,
            "end_column": 0,
            "end_line": 0,
            "file_name": "",
            "start": 0,
            "start_column": 0,
            "start_line": 0,
        },
        "text": "",
        "token_number": 0,
        "token_type": 0,
    },
} 2.0)) * ddtheta_ref) + (c * dtheta_ref)) + (((m * g) * l) * sin(theta_ref)))),
            u - ((u_ff + (((Kp * e) + (Ki * xi)) - (Kd * omega_f))))])
        self.fx = flatten_piecewise_with_nested_matrices(self.fx)

        # ============================================
        # Define Reset Functions: fr

        # ============================================
        # Define Condition Update Function: fc
        self.fc = sympy.Tuple(*[])
        self.f_c = sympy.lambdify(
            args=[self.time, self.x],
            expr=self.fc,
            modules=['numpy'])

        # ============================================
        # Events and Event callbacks

    def solve(self):
        # ============================================
        # Solve for explicit ODE
        v = sympy.Matrix(list(self.x_dot) + list(self.y))

        if isinstance(self.fx, sympy.Piecewise):
            sol_x_dot = []
            sol_y = []
            for arg in self.fx.args:
                condition = arg[1]
                sol_i = sympy.solve(arg[0], v)
                x_dot_i = sympy.Tuple(* [xi for xi in self.x_dot.subs(sol_i)])
                sol_x_dot.append((x_dot_i, condition))
                y_i = sympy.Tuple(* [yi for yi in self.y.subs(sol_i)])
                sol_y.append((y_i, condition))
            self.sol_x_dot = sympy.Piecewise(*sol_x_dot)
            self.sol_y = sympy.Piecewise(*sol_y)
        else:
            sol = sympy.solve(self.fx, v)
            self.sol_x_dot = sympy.Tuple(* [xi for xi in self.x_dot.subs(sol)])
            self.sol_y = sympy.Tuple(* [yi for yi in self.y.subs(sol)])
        
        self.f_x_dot = sympy.lambdify(
            args=[self.time, self.x, self.m, self.u, self.p, self.c],
            expr=self.sol_x_dot,
            modules=['numpy'])

        self.f_y = sympy.lambdify(
            args=[self.time, self.x, self.m, self.u, self.p, self.c],
            expr=self.sol_y,
            modules=['numpy'])

        self.solved = True

    def __repr__(self):
        return repr(self.__dict__)

    def simulate(self, t0, tf, dt, x0=None, f_u=None, max_events=100):
        """
        Simulate the modelica model
        """
        if not self.solved:
            self.solve()
        
        if f_u is None:
            def f_u(t):
                return np.zeros(self.u.shape[0])

        # ============================================
        # Declare initial vectors
        u0 = np.array([self.u0[k] for k in self.u0.keys()])
        p0 = np.array([self.p0[k] for k in self.p0.keys()])
        cp0 = np.array([self.cp0[k] for k in self.cp0.keys()])
        c0 = np.array([self.c0[k] for k in self.c0.keys()])
        m0 = np.array([self.m0[k] for k in self.m0.keys()])
        y0 = np.array([self.y0[k] for k in self.y0.keys()])
        z0 = np.array([self.z0[k] for k in self.z0.keys()])
        
        if x0 is None:
            x0 = np.array([self.x0[k] for k in self.x0.keys()])

        # ============================================
        # Declare Events
        events = []

        event_callback = {}

        # ============================================
        # Solve IVP
        event_count = 0
        t1 = tf
        data = {
            't': [],
            'x': [],
            'u': [],
            'y': [],
            'c': [],
        }

        while t0 < tf - dt:
            # check for max events
            if event_count > max_events:
                raise RuntimeError("Max events reached")
            
            # update conditions
            c0 = self.f_c(t0, x0)

            # solve ivp
            t_eval = np.arange(t0, tf, dt)
            res = scipy.integrate.solve_ivp(
                y0=x0,
                fun=lambda ti, x: self.f_x_dot(ti, x, m0, f_u(ti), p0, c0),
                t_span=[t_eval[0], t_eval[-1]],
                t_eval=t_eval,
                events=events,
            )

            # check for event
            x1 = res['y'][:, -1]
            t1 = res['t'][-1]
            if res.t_events is not None:
                event_count += 1
                for i, t_event in enumerate(res.t_events):
                    if len(t_event) > 0:
                        if i in event_callback:
                            x1 = event_callback[i](t_event[i], x1)

            # store data
            x = res['y']
            t = res['t']
            u = np.array([ f_u(ti) for ti in t ]).T
            y = np.array([ self.f_y(ti, xi, m0, ui, p0, c0) for (ti, xi, ui) in zip(t, x.T, u.T) ]).T
            data['x'].append(x)
            data['t'].append(t)
            data['u'].append(u)
            data['y'].append(y)
            data['c'].append(c0)

            # update for next step
            t0 = t1
            x0 = x1
        
        # convert lists to numpy array
        for k in data.keys():
            if len(data[k]) > 0:
                data[k] = np.hstack(data[k])
                
        return data
