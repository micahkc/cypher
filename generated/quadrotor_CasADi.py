"""
Automatically generated by Rumoca
"""
import casadi as ca
import numpy as np
sin = ca.sin
cos = ca.cos
tan = ca.tan

class Model:
    """
    Flattened Modelica Model
    """

    def __init__(self, model_name):
        # ============================================
        # Initialize


        # Create new dae
        dae = ca.DaeBuilder(model_name)
        # ============================================
        # Declare time
        time = dae.add('time', 'independent')
        # If equations update time
        dt = 0.01

        # ============================================
        # Declare u

        a = dae.add('a', 'input', dict(start = 0.0))
        e = dae.add('e', 'input', dict(start = 0.0))
        r = dae.add('r', 'input', dict(start = 0.0))
        t = dae.add('t', 'input', dict(start = 0.0))
        # ============================================
        # Declare p

        l = dae.add('l', 'parameter', 'tunable', dict(start = 1.0))
        mix_a = dae.add('mix_a', 'parameter', 'tunable', dict(start = 1.0))
        mix_e = dae.add('mix_e', 'parameter', 'tunable', dict(start = 1.0))
        mix_r = dae.add('mix_r', 'parameter', 'tunable', dict(start = 10.0))
        mix_t = dae.add('mix_t', 'parameter', 'tunable', dict(start = 32.0))
        m = dae.add('m', 'parameter', 'tunable', dict(start = 1.0))
        g = dae.add('g', 'parameter', 'tunable', dict(start = 9.81))
        J_x = dae.add('J_x', 'parameter', 'tunable', dict(start = 1.0))
        J_y = dae.add('J_y', 'parameter', 'tunable', dict(start = 1.0))
        J_z = dae.add('J_z', 'parameter', 'tunable', dict(start = 1.0))
        J_xz = dae.add('J_xz', 'parameter', 'tunable', dict(start = 0.0))
        Lambda = dae.add('Lambda', 'parameter', 'tunable', dict(start = 1.0))
        m_1_Cm = dae.add('m_1_Cm', 'parameter', 'tunable', dict(start = 0.01))
        m_1_Ct = dae.add('m_1_Ct', 'parameter', 'tunable', dict(start = 0.01))
        m_1_tau = dae.add('m_1_tau', 'parameter', 'tunable', dict(start = 0.1))
        m_2_Cm = dae.add('m_2_Cm', 'parameter', 'tunable', dict(start = 0.01))
        m_2_Ct = dae.add('m_2_Ct', 'parameter', 'tunable', dict(start = 0.01))
        m_2_tau = dae.add('m_2_tau', 'parameter', 'tunable', dict(start = 0.1))
        m_3_Cm = dae.add('m_3_Cm', 'parameter', 'tunable', dict(start = 0.01))
        m_3_Ct = dae.add('m_3_Ct', 'parameter', 'tunable', dict(start = 0.01))
        m_3_tau = dae.add('m_3_tau', 'parameter', 'tunable', dict(start = 0.1))
        m_4_Cm = dae.add('m_4_Cm', 'parameter', 'tunable', dict(start = 0.01))
        m_4_Ct = dae.add('m_4_Ct', 'parameter', 'tunable', dict(start = 0.01))
        m_4_tau = dae.add('m_4_tau', 'parameter', 'tunable', dict(start = 0.1))
        # ============================================
        # Declare c# ============================================
        # Declare cp

        # ============================================
        # Declare x

        x = dae.add('x', dict(start = 0.0))
        y = dae.add('y', dict(start = 0.0))
        h = dae.add('h', dict(start = 0.0))
        P = dae.add('P', dict(start = 0.0))
        Q = dae.add('Q', dict(start = 0.0))
        R = dae.add('R', dict(start = 0.0))
        U = dae.add('U', dict(start = 0.0))
        V = dae.add('V', dict(start = 0.0))
        W = dae.add('W', dict(start = 0.0))
        phi = dae.add('phi', dict(start = 0.0))
        theta = dae.add('theta', dict(start = 0.0))
        psi = dae.add('psi', dict(start = 0.0))
        m_1_omega = dae.add('m_1_omega', dict(start = 0.0))
        m_2_omega = dae.add('m_2_omega', dict(start = 0.0))
        m_3_omega = dae.add('m_3_omega', dict(start = 0.0))
        m_4_omega = dae.add('m_4_omega', dict(start = 0.0))
        # ============================================
        # Declare m

        # ============================================
        # Declare y

        m_1_moment = dae.add('m_1_moment', dict(start = 0.0))
        m_2_moment = dae.add('m_2_moment', dict(start = 0.0))
        m_3_moment = dae.add('m_3_moment', dict(start = 0.0))
        m_4_moment = dae.add('m_4_moment', dict(start = 0.0))
        F_x = dae.add('F_x', dict(start = 0.0))
        F_y = dae.add('F_y', dict(start = 0.0))
        F_z = dae.add('F_z', dict(start = 0.0))
        M_x = dae.add('M_x', dict(start = 0.0))
        M_y = dae.add('M_y', dict(start = 0.0))
        M_z = dae.add('M_z', dict(start = 0.0))
        m_1_omega_ref = dae.add('m_1_omega_ref', dict(start = 0.0))
        m_1_thrust = dae.add('m_1_thrust', dict(start = 0.0))
        m_2_omega_ref = dae.add('m_2_omega_ref', dict(start = 0.0))
        m_2_thrust = dae.add('m_2_thrust', dict(start = 0.0))
        m_3_omega_ref = dae.add('m_3_omega_ref', dict(start = 0.0))
        m_3_thrust = dae.add('m_3_thrust', dict(start = 0.0))
        m_4_omega_ref = dae.add('m_4_omega_ref', dict(start = 0.0))
        m_4_thrust = dae.add('m_4_thrust', dict(start = 0.0))
        # ============================================
        # Declare z

        


        # ============================================
        # Declare pre_x
        pre_x = dae.pre(x)
        pre_y = dae.pre(y)
        pre_h = dae.pre(h)
        pre_P = dae.pre(P)
        pre_Q = dae.pre(Q)
        pre_R = dae.pre(R)
        pre_U = dae.pre(U)
        pre_V = dae.pre(V)
        pre_W = dae.pre(W)
        pre_phi = dae.pre(phi)
        pre_theta = dae.pre(theta)
        pre_psi = dae.pre(psi)
        pre_m_1_omega = dae.pre(m_1_omega)
        pre_m_2_omega = dae.pre(m_2_omega)
        pre_m_3_omega = dae.pre(m_3_omega)
        pre_m_4_omega = dae.pre(m_4_omega)
        # ============================================
        # Declare pre_m
        # ============================================
        # Declare pre_z
        # ============================================
        # Define Condition Update Function: fc
        

        # ============================================
        # Define reset functions: fr
        # ============================================
        # Declare x_dot
        der_x = dae.der(x)
        der_y = dae.der(y)
        der_h = dae.der(h)
        der_P = dae.der(P)
        der_Q = dae.der(Q)
        der_R = dae.der(R)
        der_U = dae.der(U)
        der_V = dae.der(V)
        der_W = dae.der(W)
        der_phi = dae.der(phi)
        der_theta = dae.der(theta)
        der_psi = dae.der(psi)
        der_m_1_omega = dae.der(m_1_omega)
        der_m_2_omega = dae.der(m_2_omega)
        der_m_3_omega = dae.der(m_3_omega)
        der_m_4_omega = dae.der(m_4_omega)
        # ============================================
        def if_else_builder(s, builder, terminal_state):
            state = terminal_state
            for i, (cond, value) in enumerate(reversed(builder)):
                state = ca.if_else(s == int(cond[1:]), value, state)
            return state

        def if_else_builder2(builder, terminal_state):
            state = terminal_state
            for cond, value in reversed(builder):
                state = ca.if_else(cond, value, state)
            return state
        # ============================================

        def add_expression(dictionary, var, expression):
            if var not in dictionary.keys():
                dictionary[var] = []
            dictionary[var].append(expression)
                
            return dictionary
        # Define Continous Update Function: fx
        dae.eq(F_x, -(((m * g) * sin(theta))))
        dae.eq(F_y, (((m * g) * sin(phi)) * cos(theta)))
        dae.eq(F_z, ((((m * g) * cos(phi)) * cos(theta)) - (((m_1_thrust + m_2_thrust) + m_3_thrust) + m_4_thrust)))
        dae.eq(M_x, (l * (((-(m_1_thrust) + m_2_thrust) - m_3_thrust) + m_4_thrust)))
        dae.eq(M_y, (l * (((-(m_1_thrust) + m_2_thrust) + m_3_thrust) - m_4_thrust)))
        dae.eq(M_z, (((m_1_moment + m_2_moment) - m_3_moment) - m_4_moment))
        dae.eq(m_1_omega_ref, ((((t * mix_t) - (a * mix_a)) + (e * mix_e)) + (r * mix_r)))
        dae.eq(m_2_omega_ref, ((((t * mix_t) + (a * mix_a)) - (e * mix_e)) + (r * mix_r)))
        dae.eq(m_3_omega_ref, ((((t * mix_t) - (a * mix_a)) - (e * mix_e)) - (r * mix_r)))
        dae.eq(m_4_omega_ref, ((((t * mix_t) + (a * mix_a)) + (e * mix_e)) - (r * mix_r)))
        dae.eq(der_x, ((((U * cos(theta)) * cos(psi)) + (V * (-((cos(phi) * sin(psi))) + ((sin(phi) * sin(theta)) * cos(psi))))) + (W * ((sin(phi) * sin(psi)) + ((cos(phi) * sin(theta)) * cos(psi))))))
        dae.eq(der_y, ((((U * cos(theta)) * sin(psi)) + (V * ((cos(phi) * cos(psi)) + ((sin(phi) * sin(theta)) * sin(psi))))) + (W * (-((sin(phi) * cos(psi))) + ((cos(phi) * sin(theta)) * sin(psi))))))
        dae.eq(der_h, (((U * sin(theta)) - ((V * sin(phi)) * cos(theta))) - ((W * cos(phi)) * cos(theta))))
        dae.eq(der_U, (((R * V) - (Q * W)) + (F_x / m)))
        dae.eq(der_V, ((-((R * U)) + (P * W)) + (F_y / m)))
        dae.eq(der_W, (((Q * U) - (P * V)) + (F_z / m)))
        dae.eq(der_phi, (P + (tan(theta) * ((Q * sin(phi)) + (R * cos(phi))))))
        dae.eq(der_theta, ((Q * cos(phi)) - (R * sin(phi))))
        dae.eq(der_psi, (((Q * sin(phi)) + (R * cos(phi))) / cos(theta)))
        dae.eq(der_P, (((((((J_xz * ((J_x - J_y) + J_z)) * P) * Q) - ((((J_z * (J_z - J_y)) + (J_xz * J_xz)) * Q) * R)) + (J_z * M_x)) + (J_xz * M_z)) / Lambda))
        dae.eq(der_Q, ((((((J_z - J_x) * P) * R) - (J_xz * ((P * P) - (R * R)))) + M_y) / J_y))
        dae.eq(der_R, (((((((((J_x - J_y) * J_x) + (J_xz * J_xz)) * P) * Q) - (((J_xz * ((J_x - J_y) + J_z)) * Q) * R)) + (J_xz * M_x)) + (J_x * M_z)) / Lambda))
        dae.eq(der_m_1_omega, ((1.0 / m_1_tau) * (m_1_omega_ref - m_1_omega)))
        dae.eq(m_1_thrust, ((m_1_Ct * m_1_omega) * m_1_omega))
        dae.eq(m_1_moment, (m_1_Cm * m_1_thrust))
        dae.eq(der_m_2_omega, ((1.0 / m_2_tau) * (m_2_omega_ref - m_2_omega)))
        dae.eq(m_2_thrust, ((m_2_Ct * m_2_omega) * m_2_omega))
        dae.eq(m_2_moment, (m_2_Cm * m_2_thrust))
        dae.eq(der_m_3_omega, ((1.0 / m_3_tau) * (m_3_omega_ref - m_3_omega)))
        dae.eq(m_3_thrust, ((m_3_Ct * m_3_omega) * m_3_omega))
        dae.eq(m_3_moment, (m_3_Cm * m_3_thrust))
        dae.eq(der_m_4_omega, ((1.0 / m_4_tau) * (m_4_omega_ref - m_4_omega)))
        dae.eq(m_4_thrust, ((m_4_Ct * m_4_omega) * m_4_omega))
        dae.eq(m_4_moment, (m_4_Cm * m_4_thrust))
        


        dae.sort('w')
        self.dae = dae
    def display(self):
        self.dae.disp(True)

    def simulate(self, t0, tf, dt, x0=None, p0=None, f_u=None, max_events=100):
        """
        Simulate the modelica model
        """
        if p0 is None:
            p0 = self.dae.start(self.dae.p())
        
        if x0 is None:
            x0 = self.dae.start(self.dae.x())

        tgrid = np.arange(t0, tf, dt)
        simopts = dict(transition = self.dae.transition(), verbose = False,
            event_tol = 1e-12, max_events = 100000, max_event_iter = 2000)

        sim = ca.integrator('sim', 'cvodes', self.dae.create(), 0, tgrid, simopts)

        if f_u is None:
            simres = sim(x0 = x0, p = p0)
        else:
            simres = sim(x0 = x0, p = p0, u=f_u)

        return tgrid, simres
