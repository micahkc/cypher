"""
Automatically generated by Rumoca
"""
import casadi as ca
import numpy as np
sin = ca.sin
cos = ca.cos
tan = ca.tan

class Model:
    """
    Flattened Modelica Model
    """

    def __init__(self, model_name):
        # ============================================
        # Initialize


        # Create new dae
        dae = ca.DaeBuilder(model_name)
        # ============================================
        # Declare time
        time = dae.add('time', 'independent')
        # If equations update time
        dt = 0.01

        # ============================================
        # Declare u

        theta_ref = dae.add('theta_ref', 'input', dict(start = 0.0))
        dtheta_ref = dae.add('dtheta_ref', 'input', dict(start = 0.0))
        ddtheta_ref = dae.add('ddtheta_ref', 'input', dict(start = 0.0))
        d = dae.add('d', 'input', dict(start = 0.0))
        # ============================================
        # Declare p

        m = dae.add('m', 'parameter', 'tunable', dict(start = 0.0))
        l = dae.add('l', 'parameter', 'tunable', dict(start = 0.0))
        g = dae.add('g', 'parameter', 'tunable', dict(start = 0.0))
        c = dae.add('c', 'parameter', 'tunable', dict(start = 0.0))
        Kp = dae.add('Kp', 'parameter', 'tunable', dict(start = 0.0))
        Ki = dae.add('Ki', 'parameter', 'tunable', dict(start = 0.0))
        Kd = dae.add('Kd', 'parameter', 'tunable', dict(start = 0.0))
        N = dae.add('N', 'parameter', 'tunable', dict(start = 0.0))
        # ============================================
        # Declare c# ============================================
        # Declare cp

        # ============================================
        # Declare x

        theta = dae.add('theta', dict(start = 0.0))
        omega = dae.add('omega', dict(start = 0.0))
        xi = dae.add('xi', dict(start = 0.0))
        omega_f = dae.add('omega_f', dict(start = 0.0))
        # ============================================
        # Declare m

        # ============================================
        # Declare y

        e = dae.add('e', dict(start = 0.0))
        u = dae.add('u', dict(start = 0.0))
        u_ff = dae.add('u_ff', dict(start = 0.0))
        # ============================================
        # Declare z

        


        # ============================================
        # Declare pre_x
        pre_theta = dae.pre(theta)
        pre_omega = dae.pre(omega)
        pre_xi = dae.pre(xi)
        pre_omega_f = dae.pre(omega_f)
        # ============================================
        # Declare pre_m
        # ============================================
        # Declare pre_z
        # ============================================
        # Define Condition Update Function: fc
        

        # ============================================
        # Define reset functions: fr
        # ============================================
        # Declare x_dot
        der_theta = dae.der(theta)
        der_omega = dae.der(omega)
        der_xi = dae.der(xi)
        der_omega_f = dae.der(omega_f)
        # ============================================
        def if_else_builder(s, builder, terminal_state):
            state = terminal_state
            for i, (cond, value) in enumerate(reversed(builder)):
                state = ca.if_else(s == int(cond[1:]), value, state)
            return state

        def if_else_builder2(builder, terminal_state):
            state = terminal_state
            for cond, value in reversed(builder):
                state = ca.if_else(cond, value, state)
            return state
        # ============================================

        def add_expression(dictionary, var, expression):
            if var not in dictionary.keys():
                dictionary[var] = []
            dictionary[var].append(expression)
                
            return dictionary
        # Define Continous Update Function: fx
        dae.eq(der_theta, omega)
        dae.eq(der_omega, ((-(((g / l) * sin(theta))) - ((c / (m * (l UNHANDLED OP: {
    "Exp": {
        "location": {
            "end": 0,
            "end_column": 0,
            "end_line": 0,
            "file_name": "",
            "start": 0,
            "start_column": 0,
            "start_line": 0,
        },
        "text": "",
        "token_number": 0,
        "token_type": 0,
    },
} 2.0))) * omega)) + ((u + d) / (m * (l UNHANDLED OP: {
    "Exp": {
        "location": {
            "end": 0,
            "end_column": 0,
            "end_line": 0,
            "file_name": "",
            "start": 0,
            "start_column": 0,
            "start_line": 0,
        },
        "text": "",
        "token_number": 0,
        "token_type": 0,
    },
} 2.0)))))
        dae.eq(e, (theta_ref - theta))
        dae.eq(der_xi, e)
        dae.eq(der_omega_f, (N * (omega - omega_f)))
        dae.eq(u_ff, ((((m * (l UNHANDLED OP: {
    "Exp": {
        "location": {
            "end": 0,
            "end_column": 0,
            "end_line": 0,
            "file_name": "",
            "start": 0,
            "start_column": 0,
            "start_line": 0,
        },
        "text": "",
        "token_number": 0,
        "token_type": 0,
    },
} 2.0)) * ddtheta_ref) + (c * dtheta_ref)) + (((m * g) * l) * sin(theta_ref))))
        dae.eq(u, (u_ff + (((Kp * e) + (Ki * xi)) - (Kd * omega_f))))
        


        dae.sort('w')
        self.dae = dae
    def display(self):
        self.dae.disp(True)

    def simulate(self, t0, tf, dt, x0=None, p0=None, f_u=None, max_events=100):
        """
        Simulate the modelica model
        """
        if p0 is None:
            p0 = self.dae.start(self.dae.p())
        
        if x0 is None:
            x0 = self.dae.start(self.dae.x())

        tgrid = np.arange(t0, tf, dt)
        simopts = dict(transition = self.dae.transition(), verbose = False,
            event_tol = 1e-12, max_events = 100000, max_event_iter = 2000)

        sim = ca.integrator('sim', 'cvodes', self.dae.create(), 0, tgrid, simopts)

        if f_u is None:
            simres = sim(x0 = x0, p = p0)
        else:
            simres = sim(x0 = x0, p = p0, u=f_u)

        return tgrid, simres
